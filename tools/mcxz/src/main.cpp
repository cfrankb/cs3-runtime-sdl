#include <cstdlib>
#include <time.h>
#include <unistd.h>
#include <string>
#include <cstring>
#include <unordered_map>
#include <map>
#include <vector>
#include <iostream>
#include <chrono>
#include <ctime>
#include <format>
#include <filesystem>
#include <minizip/unzip.h>
#include "../../../src/shared/FileWrap.h"
#include "../../../src/shared/FrameSet.h"
#include "../../../src/shared/Frame.h"
#include "../../../src/logger.h"
#include "tileset.h"
#include "sheet.h"

constexpr const char DEFAULT_APP_NAME[] = "cs3-runtime-sdl";
constexpr const char DEFAULT_APP_AUTHOR[] = "Francois Blanchette";

enum
{
    ENCODING_RGB565,    // 2 bytes
    ENCODING_RGB565BGR, // 2 bytes
    ENCODING_RGBX555,   // 2 bytes
    ENCODING_RGBX888P,  // 1 byte
    ENCODING_RGB888,    // 3 byte
    ENCODING_RGBX888,   // 4 byte
};

struct encoding_t
{
    const char *encoding;
    uint8_t width;
};

constexpr encoding_t ENCODING_RGB[] = {
    {"565", 2},
    {"565BGR", 2},
    {"X555", 2},
    {"X888P", 1},
    {"888", 3},
    {"X888", 4},
};

typedef struct
{
    uint8_t ch;           // char for ascii map (deprecated)
    std::string name;     // WALLS93
    uint8_t type;         // 0x03
    std::string typeName; // TYPE_WALLS
    std::string define;   // TILES_WALLS93
    std::string basename; // walls93.obl
    uint8_t score;        // points to add
    int8_t health;        // health to add or remove
    uint8_t flags;        // action
    uint8_t speed;        // SLOW, NORMAL, FAST
    uint8_t ai;           // ai
    bool hidden;          // hide tile in IDE
    bool unused;          // is unused asset?
    std::string notes;    // notes about this animation
} Tile;

typedef struct
{
    uint16_t pixelWidth;
    uint8_t encoding;
    bool flipPixels;
    bool headerless;
    bool outputPNG;
    bool diet;
    std::string appName;
    std::string appAuthor;
} AppSettings;

struct group_t
{
    std::string name;
    int count;
};

struct ref_prefix_t
{
    std::string constPrefix;
    std::string enumPrefix;
};

typedef std::vector<std::string> StringVector;
typedef std::vector<Tile> TileVector;
typedef std::vector<std::string> StrVector;
typedef std::map<std::string, StringVector> Config;
typedef std::unordered_map<std::string, uint8_t> StrVal;
typedef std::map<std::string, StrVal> MapStrVal;
typedef std::unordered_map<uint32_t, uint8_t> Palette;

template <typename StringType>
StringType mid(const StringType &str, size_t start, size_t length = std::string::npos)
{
    if (start >= str.size())
        return {};
    return str.substr(start, length);
}

std::string &replaceAll(std::string &str, const std::string &from, const std::string &to)
{
    if (from.empty())
        return str;
    size_t startPos = 0;
    while ((startPos = str.find(from, startPos)) != std::string::npos)
    {
        str.replace(startPos, from.length(), to);
        startPos += to.length(); // Move past the replaced part
    }
    return str;
}

constexpr const char *AUTOGENERATED = "//////////////////////////////////////////////////\n"
                                      "// autogenerated\n\n";

constexpr const char LICENSE[] =
    "/*\n"
    "    {0}\n"
    "    Copyright (C) {1} {2}\n"
    "\n"
    "    This program is free software: you can redistribute it and/or modify\n"
    "    it under the terms of the GNU General Public License as published by\n"
    "    the Free Software Foundation, either version 3 of the License, or\n"
    "    (at your option) any later version.\n"
    "\n"
    "    This program is distributed in the hope that it will be useful,\n"
    "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
    "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
    "    GNU General Public License for more details.\n"
    "\n"
    "    You should have received a copy of the GNU General Public License\n"
    "    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n"
    "*/\n";

/**
 * @brief write license header
 *
 * @param appSettings
 * @param tfile
 */
void writeLicense(const AppSettings &appSettings, CFileWrap &tfile)
{
    const std::time_t t = std::time(0); // Get the time now
    const std::tm *now = std::localtime(&t);
    tfile += std::format(LICENSE,
                         appSettings.appName,
                         now->tm_year + 1900,
                         appSettings.appAuthor);
}

/**
 * @brief split string into a an array of substrings
 *
 * @param str
 * @param list
 */
void splitString(const std::string str,
                 StringVector &list)
{
    int i = 0;
    unsigned int j = 0;
    while (j < str.length())
    {
        if (isspace(str[j]))
        {
            const std::string tmp = str.substr(i, j - i);
            list.push_back(tmp);
            while (isspace(str[j]) && j < str.length())
            {
                ++j;
            }
            i = j;
            continue;
        }
        ++j;
    }
    list.push_back(str.substr(i, j - i));
}

/**
 * @brief string to uppercase
 *
 * @param in
 * @return std::string
 */
std::string str2upper(const std::string &in)
{
    // Convert to uppercase
    std::string basename = in;
    std::transform(basename.begin(), basename.end(), basename.begin(),
                   [](unsigned char c)
                   { return std::toupper(c); });
    return basename;
}

// RGB 565
uint16_t rgb888torgb565(const uint8_t *rgb888Pixel)
{
    const uint8_t &red = rgb888Pixel[0];
    const uint8_t &green = rgb888Pixel[1];
    const uint8_t &blue = rgb888Pixel[2];

    const uint16_t b = (blue >> 3) & 0x1f;
    const uint16_t g = ((green >> 2) & 0x3f) << 5;
    const uint16_t r = ((red >> 3) & 0x1f) << 11;
    return (uint16_t)(r | g | b);
}

// RGB 555
uint16_t rgb888torgb555(const uint8_t *rgb888Pixel)
{
    const uint8_t &red = rgb888Pixel[0];
    const uint8_t &green = rgb888Pixel[1];
    const uint8_t &blue = rgb888Pixel[2];

    const uint16_t b = (blue >> 3) & 0x1f;
    const uint16_t g = ((green >> 3) & 0x1f) << 5;
    const uint16_t r = ((red >> 3) & 0x1f) << 10;
    return (uint16_t)(r | g | b);
}

/**
 * @brief generate test file
 *
 * @return int
 */
int test()
{
    CFileWrap tfileTiny;
    tfileTiny.open("out/test_output.obl", "wb");

    CFileWrap sfile;
    if (sfile.open("obl5/annie2.obl", "rb"))
    {
        CFrameSet images;
        if (images.extract(sfile))
        {
            LOGI("images:%lu", images.getSize());
        }
        int count = images.getSize();
        CFrameSet imagesTiny;
        for (int i = 0; i < count; ++i)
        {
            CFrame *s = images[i];
            CFrame *t = new CFrame;
            t->copy(s);
            t->resize(32, 32);
            int shiftRight = (32 - s->width()) / 2;
            for (int j = 0; j < shiftRight; ++j)
            {
                t->shiftRIGHT();
            }
            int shiftDown = (32 - s->height()) / 2;
            for (int j = 0; j < shiftDown; ++j)
            {
                t->shiftDOWN();
            }
            t->shrink();
            imagesTiny.add(t);
        }

        CTileSet tiles(16, 16, count);
        for (int i = 0; i < count; ++i)
        {
            LOGI("image:%d", i);
            CFrame *frame = imagesTiny[i];
            uint32_t *rgb888 = frame->getRGB().data();
            int pixels = frame->width() * frame->height();
            uint16_t rgb565[pixels];

            for (int j = 0; j < pixels; ++j)
            {
                rgb565[j] = rgb888torgb565(reinterpret_cast<uint8_t *>(&rgb888[j]));
            }
            tiles.set(i, rgb565);
        }

        imagesTiny.write(tfileTiny);
        tiles.write("out/test_output.mcz");
    }
    else
    {
        puts("failed to open");
    }

    return EXIT_SUCCESS;
}

/**
 * @brief parse raw config file data
 *
 * @param conf
 * @param list
 * @param src
 * @return true
 * @return false
 */

bool parseConfig(Config &conf,
                 StrVector &list,
                 const char *src)
{
    char *ptr = nullptr;
    FILE *sfile = fopen(src, "rb");
    if (sfile)
    {
        fseek(sfile, 0, SEEK_END);
        long size = ftell(sfile);
        ptr = new char[size + 1];
        ptr[size] = 0;
        fseek(sfile, 0, SEEK_SET);
        fread(ptr, size, 1, sfile);
        fclose(sfile);
    }
    else
    {
        LOGE("can't open %s", src);
        return false;
    }
    char *s = ptr;

    int line = 0;
    char *sName = nullptr;
    while (s && *s)
    {
        ++line;
        // find next line
        char *n = strstr(s, "\n");
        char *b = nullptr;
        if (n)
        {
            // truncate line on return char
            *n = 0;
            b = n - 1;
            ++n;
        }

        // remove comment
        char *c = strstr(s, "#");
        if (c)
        {
            *c = 0;
            if (c < b)
            {
                b = c - 1;
            }
        }

        // trim right
        while (b >= s && isspace(*b))
        {
            *b = 0;
            --b;
        }

        // trim left
        while (isspace(*s))
        {
            ++s;
        }

        if (*s != '\0')
        {
            if (*s == '[')
            {
                sName = s + 1;
                // section header
                char *se = strstr(s, "]");
                if (se)
                {
                    *se = 0;
                    list.push_back(sName);
                }
                else
                {
                    LOGW("section head `%s` on line %d missing right bracket.", s, line);
                }
            }
            else
            {
                if (sName != nullptr)
                {
                    conf[sName].push_back(s);
                }
                else
                {
                    LOGW("file def on line %d without section.", line);
                }
            }
        }
        s = n;
    }
    delete[] ptr;
    return true;
}

/**
 * @brief generate constants list
 *
 * @param rows
 * @param prefix
 * @param constMap
 * @param constList
 * @return true
 * @return false
 */

bool processConst(StringVector &rows,
                  const ref_prefix_t &refPrefix,
                  StrVal &constMap,
                  StringVector &enumList)
{
    for (const auto &row : rows)
    {
        StringVector list;
        splitString(row, list);
        std::string key = str2upper(list[0]);
        if (list.size() < 2)
        {
            LOGW("missing second value for: %s", key.c_str());
            continue;
        }
        u_int8_t val = list[1].substr(0, 2) == "0x" ? std::stoi(list[1], 0, 16) : std::stoi(list[1], 0, 10);
        constMap[key] = val;
        const std::string name = std::format("{0}_{1}", refPrefix.constPrefix, key);
        const std::string enum_line = std::format("    {0:25s} = 0x{1:02x},\n", name, val);
        enumList.push_back(enum_line);
    }
    return true;
}

/** Write constants to special header file
 * @brief
 *
 * @param appSettings
 * @param constLists
 * @return true
 * @return false
 */
bool writeConstFile(const AppSettings &appSettings,
                    Config &enumLists,
                    std::map<std::string, ref_prefix_t> &sectionRefs)
{
    CFileWrap tfile;
    const char *fname = "out/sprtypes.h";
    if (tfile.open(fname, "wb"))
    {
        writeLicense(appSettings, tfile);
        tfile += AUTOGENERATED;
        tfile += "#pragma once\n";
        tfile += "#include <cstdint>\n";

        for (const auto &[k, list] : enumLists)
        {
            if (list.empty())
                continue;
            tfile += "\n";
            tfile += "// @enum\n";
            const std::string enum_start = std::format("enum {}:uint8_t\n{{\n", sectionRefs[k].enumPrefix);
            tfile += enum_start;
            for (const auto &line : list)
                tfile += line;
            tfile += "};\n\n";
        }
        tfile.close();
        return true;
    }
    else
    {
        LOGE("cannot create %s", fname);
        return false;
    }
}

/**
 * @brief take a filepath and create a tile name
 *
 * @param src
 * @return std::string
 */
std::string formatTitleName(const std::string &filepath)
{
    std::string basename = std::filesystem::path(filepath).stem().string();
    for (auto &c : basename)
    {
        if (!isalnum(c) && !(c == '_'))
        {
            c = '_';
        }
        else if (isalpha(c))
        {
            c = toupper(c);
        }
    }
    return basename;
}

/** get the basename from the filepath
 * @brief Get the Basename string
 *
 * @param filepath
 * @return std::string
 */
std::string getBasename(const char *filepath)
{
    const std::filesystem::path fsPath(filepath);
    const std::string filename = fsPath.filename().string();
    return filename;
}

/**
 * @brief generate C++ header file for game project
 *
 * @param appSettings
 * @param section
 * @param sectionName
 * @param sectionBasename
 * @param tileDefs
 * @param fileStats
 * @param useTileDefs
 * @return true
 * @return false
 */

bool generateHeader(const AppSettings &appSettings,
                    const std::string section,
                    const std::string sectionName,
                    TileVector &tileDefs,
                    std::vector<group_t> &fileStats,
                    const bool useTileDefs)
{
    const std::string fnameHdr = section + "data.h";
    CFileWrap tfileHdr;
    if (!tfileHdr.open(fnameHdr.c_str(), "wb"))
    {
        LOGE("can't create %s", fnameHdr.c_str());
        return false;
    }

    //////////////////////////////////////////////////////////////////////
    // file header

    writeLicense(appSettings, tfileHdr);
    tfileHdr += AUTOGENERATED;
    tfileHdr += "#pragma once\n\n";
    if (useTileDefs)
    {
        const std::string defHdr = section + "defs.h";
        CFileWrap tfileDef;
        if (!tfileDef.open(defHdr.c_str(), "wb"))
        {
            LOGE("can't create %s", defHdr.c_str());
            return false;
        }

        writeLicense(appSettings, tfileDef);
        tfileDef += AUTOGENERATED;
        tfileDef += "#pragma once\n\n";

        tfileDef += "#include <cstdint>\n\n"
                    "struct TileDef\n"
                    "{\n"
                    "    uint8_t flags;\n"
                    "    uint8_t type;\n"
                    "    uint8_t score;\n"
                    "    int8_t health;\n"
                    "    uint8_t speed;\n"
                    "    uint8_t ai;\n"
                    "    bool hidden;\n"
                    "    const char * basename;\n"
                    "};\n"
                    "uint8_t getChTile(uint8_t i) ;\n"
                    "const TileDef * getTileDefs();\n"
                    "const TileDef & getTileDef(int i);\n\n";

        tfileDef.close();
    }

    size_t j = section.find_last_of("/");
    std::string enumName = j != std::string::npos ? section.substr(j + 1, section.size() - j - 1) : section;
    enumName[0] = toupper(enumName[0]);
    tfileHdr += "// @enum\n";
    tfileHdr += std::format("enum {}\n{{\n", enumName);
    int i = 0;
    for (const auto &tile : tileDefs)
    {
        tfileHdr += std::format("    {0:25s} = 0x{1:02x},\n", tile.define, i);
        ++i;
    }

    if (!useTileDefs)
    {
        for (auto &filestat : fileStats)
            tfileHdr += std::format("    {0:25s} = 0x{1:02x},\n", filestat.name + "_LEN", filestat.count);
    }

    const std::string sectionCount = sectionName + "_TOTAL_COUNT";
    tfileHdr += std::format("    {0:25s} = 0x{1:02x},\n", sectionCount, tileDefs.size());
    tfileHdr += "};\n";

    tfileHdr.close();
    return true;
}

/**
 * @brief generate C++ boilerplate data structures for the game
 *        to support the tileset
 *
 * @param appSettings
 * @param section
 * @param sectionBasename
 * @param tileDefs
 * @return true
 * @return false
 */

bool generateData(const AppSettings &appSettings,
                  const std::string section,
                  std::string const sectionBasename,
                  TileVector &tileDefs)
{
    const std::string fnameData = section + "data.cpp";
    CFileWrap tfileData;
    if (!tfileData.open(fnameData.c_str(), "wb"))
    {
        LOGE("failed to create %s", fnameData.c_str());
        return false;
    }

    writeLicense(appSettings, tfileData);
    tfileData += AUTOGENERATED;
    tfileData += std::format("#include \"{}data.h\"\n", sectionBasename);
    tfileData += std::format("#include \"{}defs.h\"\n", sectionBasename);
    tfileData += "#include \"sprtypes.h\"\n\n"
                 "const TileDef tileDefs[] = {\n";

    uint8_t chMap[128];
    memset(chMap, 0, sizeof(chMap));

    int warnings = 0;
    StringVector lines;
    size_t maxLenght = 0;
    for (size_t i = 0; i < tileDefs.size(); ++i)
    {
        Tile &tile = tileDefs[i];
        std::string basename = "\"" + tile.basename + "\"";
        std::string tmp = std::format("    {{0x{0:02x}, TYPE_{1}, {2}, {3}, {4}, {5}, {6}, {7}}}{8}",
                                      tile.flags, tile.typeName.c_str(),
                                      tile.score,
                                      tile.health,
                                      tile.speed,
                                      tile.ai,
                                      tile.hidden ? "true" : "false",
                                      appSettings.diet ? "nullptr" : basename.c_str(),
                                      i != tileDefs.size() - 1 ? ", " : " ");
        lines.push_back(tmp);
        maxLenght = std::max(maxLenght, tmp.length());
        if (tile.ch != 0)
        {
            if (chMap[tile.ch] != '\0')
            {
                Tile &tileOld = tileDefs[chMap[tile.ch]];
                LOGE("conflict warning: char `%c` already assigned to %s. ",
                     tile.ch, tileOld.name.c_str());
                ++warnings;
            }
            chMap[tile.ch] = i;
        }
    }

    char *padding = new char[maxLenght + 1];
    for (size_t i = 0; i < lines.size(); ++i)
    {
        Tile &tile = tileDefs[i];
        tfileData += lines[i];
        int spaces = maxLenght - lines[i].length();
        memset(padding, ' ', spaces);
        padding[spaces] = '\0';
        const std::string tmp = std::format("{0}// {1:02x} {2}\n",
                                            padding, i, tile.define);
        tfileData += tmp;
    }
    delete[] padding;
    tfileData += "};\n\n";
    if (!appSettings.diet)
    {
        tfileData += "const uint8_t chMap[] = {\n";
        for (size_t i = 0; i < sizeof(chMap); ++i)
        {
            tfileData += std::format("{0}0x{1:02x}{2}",
                                     i % 8 == 0 ? "    " : "",
                                     chMap[i],
                                     i % 8 == 7 ? ",\n" : ", ");
        }
        tfileData += "};\n\n";
        tfileData += "uint8_t getChTile(const uint8_t i)\n"
                     "{\n"
                     "  return chMap[i % sizeof(chMap)];\n"
                     "}\n\n";
    }
    tfileData += "const TileDef *getTileDefs()\n"
                 "{\n"
                 "  return tileDefs;\n"
                 "}\n\n"
                 "const TileDef &getTileDef(int i)\n"
                 "{\n"
                 "  return tileDefs[i];\n"
                 "}\n"
                 "\n";
    if (warnings)
        LOGW(">>>>%d warnings", warnings);
    tfileData.close();
    return true;
}

/**
 * @brief Generate debug information
 *
 * @param appSettings
 * @param section
 * @param sectionBasename
 * @param tileDefs
 * @param constConfig
 * @return true
 * @return false
 */

bool generateDebug(const AppSettings &appSettings,
                   const std::string section,
                   std::string const sectionBasename,
                   TileVector &tileDefs,
                   MapStrVal &constConfig)
{
    struct nameVal_t
    {
        std::string name;
        uint8_t val;
    };

    const std::string fnameData = section + "debug.cpp";
    CFileWrap tfile;
    if (!tfile.open(fnameData.c_str(), "wb"))
    {
        LOGE("failed to create %s", fnameData.c_str());
        return false;
    }

    writeLicense(appSettings, tfile);
    tfile += AUTOGENERATED;
    tfile += "#include <unordered_map>\n";
    tfile += "#include <string>\n";
    tfile += "#include <cstdint>\n";
    tfile += std::format("#include \"{}data.h\"\n", sectionBasename);
    tfile += "#include \"sprtypes.h\"\n\n";
    tfile += "#define _S(_x) {_x, #_x}\n\n";

    tfile += "static const std::unordered_map<uint16_t, std::string> g_tileNames = {\n";
    for (size_t i = 0; i < tileDefs.size(); ++i)
    {
        const Tile &tile = tileDefs[i];
        tfile += std::format("{0:4s}_S({1}),\n", " ", tile.define);
    }
    tfile += "};\n\n";

    std::vector<std::string> types = {"tileNames"};
    for (const auto &[prefix, map] : constConfig)
    {
        tfile += std::format("static const std::unordered_map<uint16_t, std::string> g_{0}Names = {{\n", prefix);
        types.push_back(prefix + "Names");
        std::string uprefix = str2upper(prefix);
        if (prefix[uprefix.length() - 1] == 's')
        {
            uprefix = uprefix.substr(0, uprefix.length() - 1);
        }

        std::vector<nameVal_t> listSorted;
        for (const auto &[name, val] : map)
        {
            listSorted.push_back({name, val});
        }

        std::sort(listSorted.begin(), listSorted.end(), [&](auto t1, auto t2)
                  { return t1.val < t2.val; });
        for (const auto &item : listSorted)
        {
            tfile += std::format("{0:4s}_S({1}_{2}),\n", " ", uprefix, item.name);
        }
        tfile += "};\n\n";
    }

    for (const auto &name : types)
    {
        tfile += std::format("std::string get_{0}(const uint16_t i)\n"
                             "{{\n"
                             "    const auto &it = g_{0}.find(i);\n"
                             "    if (it != g_{0}.end())\n"
                             "        return it->second;\n"
                             "    else\n"
                             "        return \"\";\n"
                             "}}\n\n"
                             "const std::unordered_map<uint16_t, std::string> & get_{0}Map()\n"
                             "{{\n"
                             "   return g_{0};\n"
                             "}}\n\n",
                             name);
    }

    tfile.close();

    const std::string fnameHdr = section + "debug.h";
    if (!tfile.open(fnameHdr.c_str(), "wb"))
    {
        LOGE("failed to create %s", fnameHdr.c_str());
        return false;
    }

    writeLicense(appSettings, tfile);
    tfile += AUTOGENERATED;
    tfile += "#pragma once\n";
    tfile += "#include <cinttypes>\n";
    tfile += "#include <string>\n";
    tfile += "#include <unordered_map>\n\n";

    for (const auto &name : types)
    {
        tfile += std::format("std::string get_{0}(const uint16_t i);\n"
                             "const std::unordered_map<uint16_t, std::string> & get_{0}Map();\n",
                             name);
    }

    tfile += "\n";
    return true;
}

/**
 * @brief decode parameters in a tile-list section
 *
 * @param list
 * @param constConfig
 * @param start
 * @param end
 * @param ch
 * @param useTileDefs
 * @return Tile
 */
Tile parseFileParams(const StringVector &list,
                     MapStrVal &constConfig,
                     int &start,
                     int &end,
                     std::vector<uint8_t> &ch,
                     bool &useTileDefs)
{
    Tile tile{
        .ch = 0,
        .name = formatTitleName(list[0]),
        .type = 0,
        .typeName = "NONE",
        .define = "",
        .basename = "",
        .score = 0,
        .health = 0,
        .flags = 0,
        .speed = 0,
        .ai = 0,
        .hidden = false,
        .unused = false,
        .notes = ""};
    typedef struct
    {
        StrVal *map;
        std::string name;
        uint8_t *dest;
        bool combine;
    } Params;

    typedef std::unordered_map<char, Params> MapParams;
    MapParams mapParams = MapParams{
        {'^', {&constConfig["flags"], "flags", &tile.flags, true}},
        {'&', {&constConfig["speeds"], "speeds", &tile.speed, false}},
        {':', {&constConfig["ai"], "ai", &tile.ai, true}},
    };

    for (size_t i = 1; i < list.size(); ++i)
    {
        const std::string item = list[i];
        const std::string xstring = item.length() > 0 ? item.substr(1) : "";
        const std::string ref = str2upper(xstring);
        std::size_t j;
        switch (item.c_str()[0])
        {
        case '@':
            start = std::stoi(item.substr(1));
            j = item.find(":");
            if (j == std::string::npos)
            {
                // no upper bound
                end = start + 1;
            }
            else if (!item.substr(j + 1).empty())
                end = std::stoi(item.substr(j + 1)) + 1;
            break;
        case 'x':
            ch.push_back(std::stoi(item.substr(1), 0, 16));
            break;

        default:
            if (item.length() == 1)
            {
                ch.push_back(static_cast<u_int8_t>(item[0]));
            }
            else if (item[0] == '$')
            {
                tile.score = std::stoi(item.substr(1), 0, 10);
            }
            else if (item[0] == '+')
            {
                tile.health = std::stoi(item.substr(1), 0, 10);
            }
            else if (item[0] == '-')
            {
                tile.health = -std::stoi(item.substr(1), 0, 10);
            }
            else if (item[0] == '*')
            {
                if (ref == "HIDDEN")
                {
                    tile.hidden = true;
                }
                else if (ref == "UNUSED")
                {
                    tile.unused = true;
                }
                else
                {
                    LOGE("unknown directive: %s", ref.c_str());
                }
            }
            else if (item[0] == '!')
            {
                tile.name = formatTitleName(item.substr(1));
            }
            else if (mapParams.count(item[0]) != 0)
            {
                Params &params = mapParams[item[0]];
                if (params.map->count(ref) != 0)
                {
                    if (params.combine)
                    {
                        *(params.dest) |= (*params.map)[ref];
                    }
                    else
                    {
                        *(params.dest) = (*params.map)[ref];
                    }
                }
                else
                {
                    LOGE("can't find %s: %s", params.name.c_str(), ref.c_str());
                }
            }
            else
            {
                useTileDefs = true;
                tile.typeName = item;
                if (constConfig["types"].count(item) == 0)
                {
                    LOGE("unknown type: %s", ref.c_str());
                }
                else
                {
                    tile.type = constConfig["types"][item];
                }
            }
        }
    }
    return tile;
}

/**
 * @brief generate a reference map with tileID/description pair (plain text)
 *        for developer sanity check
 *
 * @param section
 * @param tileDefs
 * @param generateHeader
 */

void writeMapFile(const std::string &section,
                  const TileVector &tileDefs,
                  const bool generateHeader)
{
    const std::string fnameMap = section + ".map";
    CFileWrap tfileMap;
    tfileMap.open(fnameMap.c_str(), "wb");
    for (size_t j = 0; j < tileDefs.size(); ++j)
    {
        const Tile &tile = tileDefs[j];
        std::string tmp;
        if (generateHeader)
        {
            tmp = std::format("{0:02x} {1:20s} {2:10s}\n", j, tile.basename, tile.typeName);
        }
        else
        {
            tmp = std::format("{0:02x} {1:20s}\n", j, tile.basename);
        }
        tfileMap += tmp;
    }
    tfileMap.close();
}

/**
 * @brief Extraxt png images from zip archive
 *
 * @param zipPath
 * @param images
 * @return true
 * @return false
 */
bool readZipFile(const std::string &zipPath, CFrameSet &images)
{
    unzFile zip = unzOpen(zipPath.c_str());
    if (!zip)
    {
        std::cerr << "Cannot open ZIP file: " << zipPath << "\n";
        return false;
    }

    if (unzGoToFirstFile(zip) != UNZ_OK)
    {
        std::cerr << "Cannot read first file in ZIP\n";
        unzClose(zip);
        return false;
    }

    do
    {
        char filename[256];
        unz_file_info fileInfo;
        if (unzGetCurrentFileInfo(zip, &fileInfo, filename, sizeof(filename), nullptr, 0, nullptr, 0) != UNZ_OK)
        {
            std::cerr << "Cannot get file info\n";
            break;
        }

        // std::cout << "Found file: " << filename << " (" << fileInfo.uncompressed_size << " bytes)\n";
        if (unzOpenCurrentFile(zip) != UNZ_OK)
        {
            std::cerr << "Cannot open file: " << filename << "\n";
            break;
        }

        std::vector<char> buffer(fileInfo.uncompressed_size);
        int bytesRead = unzReadCurrentFile(zip, buffer.data(), buffer.size());
        if (bytesRead < 0)
        {
            std::cerr << "Error reading file: " << filename << "\n";
        }
        else
        {
            namespace fs = std::filesystem;
            fs::path tmpDir = fs::temp_directory_path();
            const std::string tmpFile = std::format("{0}/mcxz{1}.bin", tmpDir.c_str(), rand());
            CFileWrap file;
            if (file.open(tmpFile.c_str(), "wb"))
            {
                file.write(buffer.data(), buffer.size());
                file.close();
                if (file.open(tmpFile.c_str(), "rb"))
                {
                    images.extract(file);
                    file.close();
                }
                fs::remove(tmpFile);
            }
        }
        unzCloseCurrentFile(zip);
    } while (unzGoToNextFile(zip) == UNZ_OK);

    unzClose(zip);
    return images.getSize() != 0;
}

/**
 * @brief Extract image from given file. Provides abstraction to support png, obl
 *        and zip sources transparently.
 *
 * @param fname
 * @param images
 * @return true
 * @return false
 */

bool extractImages(const std::string &fname, CFrameSet &images)
{
    CFileWrap sfile;
    if (fname.ends_with(".zip") && readZipFile(fname, images))
    {
        LOGI("%s images:%lu (insize zip)", fname.c_str(), images.getSize());
        return true;
    }
    else if (sfile.open(fname.c_str(), "rb"))
    {
        if (images.extract(sfile))
        {
            LOGI("%s images:%lu", fname.c_str(), images.getSize());
            return true;
        }
    }
    return false;
}

void cleanFrame(CFrame *t)
{
    const uint32_t ALPHA = 0xff000000;
    for (int y = 0; y < t->height(); ++y)
    {
        for (int x = 0; x < t->width(); ++x)
        {
            uint32_t &color = t->at(x, y);
            if ((color & ALPHA) == 0 && color != 0)
            {
                //  LOGI("x=%d y=%d color=%.8x", x, y, color);
                color = 0;
            }
            else if ((color & ALPHA) != 0 && (color & ALPHA) != ALPHA)
            {
                // LOGI("x=%d y=%d color=%.8x", x, y, color);
            }
        }
    }
}

/**
 * @brief Process a section from the Ini File. These are sections containing files of images not any of the special sections
 *
 * @param section
 * @param files
 * @param constConfig
 * @param appSettings
 * @param colors
 * @param errors
 * @return true
 * @return false
 */
bool processSection(
    const std::string section,
    StringVector &files,
    MapStrVal &constConfig,
    const AppSettings &appSettings,
    Palette &colors,
    int &errors)
{
    std::vector<group_t> fileStats;
    bool useTileDefs = false;
    const std::string sectionName = formatTitleName(section);
    const std::string sectionBasename = getBasename(section.c_str());
    const char *tinyExt = appSettings.outputPNG ? ".png" : ".obl";
    const std::string fnameTiny = section + tinyExt;
    const std::string fnameT = section + ".mcz";

    CFrameSet imagesTiny;
    int j = 0;

    TileVector tileDefs;
    CFileWrap sfile;
    for (const auto &line : files)
    {
        CFrameSet images;
        StringVector list;
        splitString(line, list);
        const char *fname = list[0].c_str();
        // read original images
        if (extractImages(list[0], images))
        {
            int count = images.getSize();
            int start = 0;
            int end = count;
            // parse args
            std::vector<uint8_t> ch;
            Tile tile = parseFileParams(list, constConfig, start, end, ch, useTileDefs);
            tile.basename = getBasename(fname);
            fileStats.push_back({sectionName + "_" + tile.name, count});

            // create shrink copies
            int u = 0;
            for (int i = start; i < end; ++i)
            {
                tile.ch = u < static_cast<uint8_t>(ch.size()) ? ch[u] : static_cast<uint8_t>(0);
                CFrame *s = images[i];
                CFrame *t = new CFrame;
                t->copy(s);

                if (t->height() > 16 || t->width() > 16)
                {
                    t->resize(32, 32);
                    int shiftRight = (32 - s->width()) / 2;
                    for (int j = 0; j < shiftRight; ++j)
                    {
                        t->shiftRIGHT();
                    }
                    int shiftDown = (32 - s->height()) / 2;
                    for (int j = 0; j < shiftDown; ++j)
                    {
                        t->shiftDOWN();
                    }
                    t->shrink();
                }
                else if (t->height() < 16 || t->width() < 16)
                {
                    t->resize(16, 16);
                }
                cleanFrame(t);
                imagesTiny.add(t);
                tile.define = sectionName + "_" + tile.name + (u ? std::format("_{:X}", u + 1) : ""); // tileName;
                tileDefs.push_back(tile);
                ++j;
                ++u;
            }
        }
        else
        {
            LOGE("failed to open: %s", fname);
            ++errors;
        }
    }

    CFileWrap tfileTiny;
    if (!tfileTiny.open(fnameTiny.c_str(), "wb"))
    {
        LOGE("can't open %s", fnameTiny.c_str());
    }
    else if (appSettings.outputPNG)
    {
        std::vector<uint8_t> png;
        if (!toSpriteSheet(imagesTiny, png, SpriteSheet::no_random_colors))
        {
            LOGE("can't create spritesheet");
            return false;
        };
        // imagesTiny.toPng(png);
        tfileTiny.write(png.data(), png.size());
    }
    else
    {
        // output to obl
        imagesTiny.write(tfileTiny);
    }

    LOGI("tiles: %lu", imagesTiny.getSize());

    // generate tileset
    CTileSet tiles(16, 16, imagesTiny.getSize(), appSettings.pixelWidth); // create tileset
    for (size_t i = 0; i < imagesTiny.getSize(); ++i)
    {
        CFrame *frame = imagesTiny[i];
        uint32_t *rgbX888 = frame->getRGB().data();
        int pixels = frame->width() * frame->height();
        int j;
        uint8_t rgb332[pixels];
        uint16_t rgb565[pixels];
        rgb24_t rgb24[pixels];

        switch (appSettings.pixelWidth)
        {
        case CTileSet::pixel8:
            if (colors.size() == 0)
            {
                colors[0] = 0;
            }
            for (j = 0; j < pixels; ++j)
            {
                const uint32_t &color = rgbX888[j] & 0xfff8f8f8;
                if (colors.count(color) == 0)
                {
                    colors[color] = colors.size();
                }
                rgb332[j] = colors[color];
            }
            tiles.set(i, rgb332);
            break;
        case CTileSet::pixel16:
            for (j = 0; j < pixels; ++j)
            {
                if (appSettings.encoding == ENCODING_RGB565)
                {
                    rgb565[j] = rgb888torgb565(reinterpret_cast<uint8_t *>(&rgbX888[j]));
                }
                if (appSettings.encoding == ENCODING_RGB565BGR)
                {
                    uint8_t *rgb = reinterpret_cast<uint8_t *>(&rgbX888[j]);
                    uint8_t bgr[4]{rgb[2], rgb[1], rgb[0], rgb[3]};
                    rgb565[j] = rgb888torgb565(bgr);
                }
                else if (appSettings.encoding == ENCODING_RGBX555)
                {
                    uint16_t color = (rgbX888[j] & 0xff000000) ? (0x8000 | rgb888torgb555(reinterpret_cast<uint8_t *>(&rgbX888[j]))) : 0;
                    rgb565[j] = color;
                }
            }
            tiles.set(i, rgb565);
            break;

        case CTileSet::pixel24:
            for (j = 0; j < pixels; ++j)
            {
                memcpy(&rgb24[j], &rgbX888[j], 3);
            }
            tiles.set(i, rgb24);
            break;

        case CTileSet::pixel32:
            tiles.set(i, rgbX888);
        };
    }
    tiles.write(fnameT.c_str(), appSettings.flipPixels, appSettings.headerless);

    // write MapFile
    writeMapFile(section, tileDefs, useTileDefs);

    // generate headers
    generateHeader(appSettings, section, sectionName, tileDefs, fileStats, useTileDefs);

    // generate data
    if (useTileDefs)
    {
        generateData(appSettings, section, sectionBasename, tileDefs);
        generateDebug(appSettings, section, sectionBasename, tileDefs, constConfig);
    }

    if (colors.size())
    {
        LOGI("palette: %lu", colors.size());
    }

    if (errors)
    {
        LOGE("\n===>>>>> %d errors", errors);
    }

    return true;
}

/**
 * @brief write 256 colors polette
 *
 * @param lastTileSet
 * @param colors
 * @return true
 * @return false
 */
bool writePalette(const std::string &lastTileSet,
                  const Palette &colors)
{
    size_t colorCount = colors.size();
    if (colorCount != 0)
    {
        const int blockSize = 8;
        const int rows = 16;
        const int cols = 16;
        CFrame frame(cols * blockSize, rows * blockSize);
        std::string palettePath = lastTileSet + ".pal";
        std::string palettePngPath = lastTileSet + "-pal.png";
        uint32_t palette[colorCount];
        LOGI("writing palette: %s", palettePath.c_str());
        for (const auto &[color, idx] : colors)
        {
            palette[idx] = color;
            auto baseX = idx & 0xf;
            auto baseY = idx >> 4;
            for (int y = 0; y < blockSize; ++y)
            {
                for (int x = 0; x < blockSize; ++x)
                {
                    frame.at(baseX * blockSize + x, baseY * blockSize + y) = color;
                }
            }
        }
        FILE *tfile = fopen(palettePath.c_str(), "wb");
        fwrite(palette, sizeof(palette), 1, tfile);
        fclose(tfile);

        std::vector<uint8_t> png;
        frame.toPng(png);
        CFileWrap file;
        if (file.open(palettePngPath.c_str(), "wb"))
        {
            file.write(png.data(), png.size());
        }
        file.close();
    }
    return true;
}

/**
 * @brief Process the .ini file designated by src abd generate the game data
 *
 * @param src
 * @param appSettings
 * @return true
 * @return false
 */
bool runJob(const char *src,
            const AppSettings &appSettings)
{

    int total_errors = 0;
    Config conf;
    Palette colors;
    std::string lastTileSet;
    StrVector sectionList;
    bool result;
    if ((result = parseConfig(conf, sectionList, src)))
    {
        MapStrVal constConfig;
        Config enumLists;
        std::map<std::string, ref_prefix_t> sectionRefs = {
            {"types", {"TYPE", "TileType"}},
            {"flags", {"FLAG", "TileFlag"}},
            {"speeds", {"SPEED", "TileSpeed"}},
            {"ai", {"AI", "TileAI"}},
        };

        for (const auto &sectionName : sectionList)
        {
            int errors = 0;
            StringVector files = conf[sectionName];
            if (sectionRefs.count(sectionName) != 0)
            {
                processConst(
                    files,
                    sectionRefs[sectionName],
                    constConfig[sectionName],
                    enumLists[sectionName]);
            }
            else
            {
                lastTileSet = sectionName;
                LOGI("[%s]", sectionName.c_str());
                processSection(
                    sectionName,
                    files,
                    constConfig,
                    appSettings,
                    colors,
                    errors);
                total_errors += errors;
            }
        }
        writeConstFile(appSettings, enumLists, sectionRefs);
    }
    writePalette(lastTileSet, colors);
    if (total_errors)
    {
        LOGE("\n****>>>> total errors: %d", total_errors);
    }
    else
    {
        LOGI("****>>>> no error found");
    }

    return result && total_errors == 0;
}

/**
 * @brief Show application usage
 *
 * @param cmd
 */
void showUsage(const char *cmd)
{
    printf(
        "mcxz tileset generator\n\n"
        "usage: \n"
        "       %s [-e?999 -r -f -p] file1.ini [file2.ini]\n"
        "\n"
        "filex.ini          job configuration\n"
        "-e?999             image/mcz encoding\n"
        "                       565 (16 bits, default)\n"
        "                       565BGR (16 bits)\n"
        "                       X555 (16 bits)\n"
        "                       X888P (8 bits + palette)\n"
        "                       888 (24 bits)\n"
        "                       X888 (32 bits)\n"
        "--app <name>       specify appName for license\n"
        "-r                 raw headerless generation (mcz raw)\n"
        "-f                 flip bytes (only applies to 16bits)\n"
        "-p                 output to png rather than obl\n"
        "-d                 strip anything not needed\n"
        "-h --help          show help\n"
        "\n",
        cmd);
}

int main(int argc, char *argv[], char *envp[])
{
    (void)envp;
    AppSettings appSettings = AppSettings{
        .pixelWidth = CTileSet::pixel16,
        .encoding = ENCODING_RGB565,
        .flipPixels = false,
        .headerless = false,
        .outputPNG = false,
        .diet = false,
        .appName = DEFAULT_APP_NAME,
        .appAuthor = DEFAULT_APP_AUTHOR,
    };
    StringVector files;

    for (int i = 1; i < argc; ++i)
    {
        char *src = argv[i];
        if (src[0] == '-')
        {
            if (strcmp(src, "--help") == 0 || strcmp(src, "-h") == 0)
            {
                showUsage(argv[0]);
                return EXIT_SUCCESS;
            }
            else if (strcmp(src, "--app") == 0)
            {
                if (i + 1 < argc && argv[i + 1][0] != '-')
                {
                    appSettings.appName = argv[++i];
                    continue;
                }
                else
                {
                    LOGE("switch: %s, missing appName", src);
                    return EXIT_FAILURE;
                }
            }
            else if (src[1] == 'e')
            {
                bool found = false;
                size_t encondingCount = sizeof(ENCODING_RGB) / sizeof(ENCODING_RGB[0]);
                for (size_t j = 0; j < encondingCount; ++j)
                {
                    if (strcmp(&src[2], ENCODING_RGB[j].encoding) == 0)
                    {
                        appSettings.encoding = j;
                        appSettings.pixelWidth = ENCODING_RGB[j].width;
                        found = true;
                        break;
                    }
                }
                if (found)
                    continue;
                else if (src[2] == '\0')
                {
                    LOGE("missing encoding value: %s", src);
                    return EXIT_FAILURE;
                }
                else
                {
                    LOGE("invalid encoding: %s", src + 2);
                    return EXIT_FAILURE;
                }
            }
            if (strlen(src) != 2)
            {
                LOGE("invalid switch: %s", src);
                return EXIT_FAILURE;
            }
            else if (src[1] == 't')
            {
                test();
                continue;
            }
            else if (src[1] == 'f')
            {
                appSettings.flipPixels = true;
                continue;
            }
            else if (src[1] == 'd')
            {
                appSettings.diet = true;
                continue;
            }
            else if (src[1] == 'r')
            {
                appSettings.headerless = true;
                continue;
            }
            else if (src[1] == 'p')
            {
                appSettings.outputPNG = true;
                continue;
            }
            LOGE("invalid switch: %s", src);
            return EXIT_FAILURE;
        }

        if (appSettings.flipPixels && appSettings.pixelWidth != CTileSet::pixel16)
        {
            LOGE("invalid flag combination. cannot flip bytes if not 16bits.");
            return EXIT_FAILURE;
        }

        const std::string t{src};
        if (!t.ends_with(".ini"))
        {
            LOGE("source %s doesn't end with .ini", src);
            return EXIT_FAILURE;
        }
        files.push_back(src);
    }

    if (files.size() == 0)
    {
        fputs("require at least one .ini file argument", stderr);
        return EXIT_FAILURE;
    }
    else
    {
        for (size_t i = 0; i < files.size(); ++i)
        {
            if (!runJob(files.at(i).c_str(), appSettings))
            {
                fputs("error encountered.", stderr);
                return EXIT_FAILURE;
            }
        }
    }
    return EXIT_SUCCESS;
}
