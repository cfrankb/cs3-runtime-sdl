<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Modularized Canvas App</title>
  <style>
    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      border: 0;
      overflow: hidden;
      display: block;
      box-sizing: border-box;
      background-color: black;
    }

    .emscripten {
      padding-right: 0;
      margin-left: auto;
      margin-right: auto;
      display: block;
    }

    textarea.emscripten {
      font-family: monospace;
      width: 80%;
      background-color: black;
      color: white;
    }

    div.emscripten {
      text-align: center;
      display: none;
    }

    .emscripten_border {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: black;
      border: 0;
    }

    /* the canvas *must not* have any border or padding, or mouse coords will be wrong */
    canvas.emscripten {
      border: 0px none;
      background-color: black;
      display: block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }

    #buttonbox {
      text-align: center;
    }

    .spinner {
      height: 50px;
      width: 50px;
      margin: 0px auto;
      -webkit-animation: rotation 0.8s linear infinite;
      -moz-animation: rotation 0.8s linear infinite;
      -o-animation: rotation 0.8s linear infinite;
      animation: rotation 0.8s linear infinite;
      border-left: 10px solid rgb(0, 150, 240);
      border-right: 10px solid rgb(0, 150, 240);
      border-bottom: 10px solid rgb(0, 150, 240);
      border-top: 10px solid rgb(100, 0, 200);
      border-radius: 100%;
      background-color: rgb(200, 100, 250);
    }

    @-webkit-keyframes rotation {
      from {
        -webkit-transform: rotate(0deg);
      }

      to {
        -webkit-transform: rotate(360deg);
      }
    }

    @-moz-keyframes rotation {
      from {
        -moz-transform: rotate(0deg);
      }

      to {
        -moz-transform: rotate(360deg);
      }
    }

    @-o-keyframes rotation {
      from {
        -o-transform: rotate(0deg);
      }

      to {
        -o-transform: rotate(360deg);
      }
    }

    @keyframes rotation {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    #fs-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      font-size: 14px;
      z-index: 1000;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      border: 1px solid white;
      cursor: pointer;
      border-radius: 4px;
    }

    #fs-btn:hover {
      background-color: rgba(0, 0, 0, 0.9);
    }
  </style>
</head>

<body>
  <button id="fs-btn">Go Fullscreen</button>

  <figure style="overflow: visible" id="spinner">
    <div class="spinner"></div>
    <center style="margin-top: 0.5em"><strong>emscripten</strong></center>
  </figure>
  <div class="emscripten" id="status">Downloading...</div>
  <div class="emscripten">
    <progress value="0" max="100" id="progress" hidden="1"></progress>
  </div>
  <div class="emscripten_border">
    <canvas class="emscripten" id="canvas" oncontextmenu="event.preventDefault()" tabindex="-1"></canvas>
  </div>

  <hr />
  <textarea class="emscripten" id="output" rows="8"></textarea>
  <hr />

  <script src="cs3-runtime.js"></script>
  <script>
    var statusElement = document.getElementById("status");
    var progressElement = document.getElementById("progress");
    var spinnerElement = document.getElementById("spinner");
    var setStatusLast = NaN;

    MyApp({
      canvas: document.getElementById('canvas'),
      locateFile: (filename) => {
        return filename;
      },
      onRuntimeInitialized: function () {
        const canvas = document.getElementById('canvas');
        const fsBtn = document.getElementById('fs-btn');

        // Define your game's aspect ratio (adjust these values to match your game)
        const GAME_WIDTH = 640;
        const GAME_HEIGHT = 480;
        const ASPECT_RATIO = GAME_WIDTH / GAME_HEIGHT;

        // Function to resize canvas while maintaining aspect ratio
        function resizeCanvas() {
          const container = canvas.parentElement;
          const containerWidth = container.clientWidth;
          const containerHeight = container.clientHeight;
          const containerAspect = containerWidth / containerHeight;

          let displayWidth, displayHeight;

          if (containerAspect > ASPECT_RATIO) {
            // Container is wider than game aspect ratio (letterbox sides)
            displayHeight = containerHeight;
            displayWidth = displayHeight * ASPECT_RATIO;
          } else {
            // Container is taller than game aspect ratio (letterbox top/bottom)
            displayWidth = containerWidth;
            displayHeight = displayWidth / ASPECT_RATIO;
          }

          // Set CSS size (display size)
          canvas.style.width = displayWidth + 'px';
          canvas.style.height = displayHeight + 'px';

          console.log(`Canvas resized to: ${displayWidth}x${displayHeight}`);
        }

        // Fullscreen button click handler
        fsBtn.addEventListener('click', () => {
          if (canvas.requestFullscreen) {
            canvas.requestFullscreen().catch(err => {
              console.error("Fullscreen request denied:", err);
            });
          } else if (canvas.webkitRequestFullscreen) {
            canvas.webkitRequestFullscreen();
          } else if (canvas.mozRequestFullScreen) {
            canvas.mozRequestFullScreen();
          } else if (canvas.msRequestFullscreen) {
            canvas.msRequestFullscreen();
          }
        });

        // Fullscreen change handler (works with both custom button and itch.io button)
        function onFullscreenChange() {
          const isFullscreen = document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement;

          if (isFullscreen) {
            console.log("Entered fullscreen");
            fsBtn.style.display = 'none';
            resizeCanvas();

            // Notify C++ code if needed
            if (typeof Module !== 'undefined' && Module._onFullscreenChange) {
              Module._onFullscreenChange(1);
            }
          } else {
            console.log("Exited fullscreen");
            fsBtn.style.display = 'block';
            resizeCanvas();

            // Notify C++ code if needed
            if (typeof Module !== 'undefined' && Module._onFullscreenChange) {
              Module._onFullscreenChange(0);
            }
          }
        }

        // Listen for all fullscreen change events
        document.addEventListener('fullscreenchange', onFullscreenChange);
        document.addEventListener('webkitfullscreenchange', onFullscreenChange);
        document.addEventListener('mozfullscreenchange', onFullscreenChange);
        document.addEventListener('MSFullscreenChange', onFullscreenChange);

        // Listen for window resize
        window.addEventListener('resize', resizeCanvas);

        // Initial resize
        resizeCanvas();

        // Start your app
        this._main();
      },
      print: (function () {
        var element = document.getElementById("output");
        if (element) element.value = "";
        return (...args) => {
          var text = args.join(" ");
          console.log(text);
          if (element) {
            element.value += text + "\n";
            element.scrollTop = element.scrollHeight;
          }
        };
      })(),
      canvas: (() => {
        var canvas = document.getElementById("canvas");
        canvas.addEventListener(
          "webglcontextlost",
          (e) => {
            alert("WebGL context lost. You will need to reload the page.");
            e.preventDefault();
          },
          false
        );
        return canvas;
      })(),
      setStatus: (text) => {
        if (setStatusLast === NaN) {
          setStatusLast = { time: Date.now(), text: "" };
        }
        if (text === setStatusLast.text) return;
        var m = text.match(/([^(]+)\((\d+(\.\d+)?)\/(\d+)\)/);
        var now = Date.now();
        if (m && now - setStatusLast.time < 30) return;
        setStatusLast.time = now;
        setStatusLast.text = text;
        if (m) {
          text = m[1];
          progressElement.value = parseInt(m[2]) * 100;
          progressElement.max = parseInt(m[4]) * 100;
          progressElement.hidden = false;
          spinnerElement.hidden = false;
        } else {
          progressElement.value = null;
          progressElement.max = null;
          progressElement.hidden = true;
          if (!text) spinnerElement.hidden = true;
        }
        statusElement.innerHTML = text;
      },
      totalDependencies: 0,
    }).then(Module => {
      window.myAppModule = Module;
      window.Module = Module;
      Module.setStatus("Downloading...");
      window.onerror = () => {
        Module.setStatus("Exception thrown, see JavaScript console");
        spinnerElement.style.display = "none";
        Module.setStatus = (text) => {
          if (text) console.error("[post-exception status] " + text);
        };
      };
    });

    // Audio setup
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const gainNode = audioCtx.createGain();
    gainNode.connect(audioCtx.destination);
    let source;

    document.addEventListener('touchstart', () => {
      if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }, { once: true });

    function setVolume(value) {
      gainNode.gain.value = value / 128;
    }

    function stopAudio() {
      if (source) {
        source.stop();
        source.disconnect();
        source = null;
      }
    }

    function startAudio(filename) {
      console.log(">>>>> " + filename);
      fetch(filename)
        .then(res => res.arrayBuffer())
        .then(data => audioCtx.decodeAudioData(data))
        .then(buffer => {
          source = audioCtx.createBufferSource();
          source.buffer = buffer;
          source.connect(gainNode);
          source.loop = true;
          source.start(0);
        });
    }

    // Gamepad support
    window.addEventListener("gamepadconnected", (e) => {
      console.log(`Gamepad connected at index ${e.gamepad.index}: ${e.gamepad.id}`);
    });

    window.addEventListener("gamepaddisconnected", (e) => {
      console.log(`Gamepad disconnected from index ${e.gamepad.index}: ${e.gamepad.id}`);
    });
  </script>
  {{{ SCRIPT }}}
</body>

</html>