import shutil
import re

notice = """
/*
    cs3-runtime-sdl
    Copyright (C) 2025  Francois Blanchette

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
""".strip()

struct = """
struct boss_seq_t
{
    int base;
    int lenght;
};

struct bossData_t
{
    const char* name;
    int speed;
    int hp;
    int type;
    int score;
    int damage;
    uint32_t flags;
    boss_seq_t moving;
    boss_seq_t attack;
    boss_seq_t hurt;
    boss_seq_t death;
    Rect hitbox;
    int sheet;
};
"""

cpp_body = """
bossData_t *getBossData(const int type)
{
    constexpr size_t bossCount = sizeof(g_bosses) / sizeof(g_bosses[0]);
    for (size_t i = 0; i < bossCount; ++i)
    {
        if (g_bosses[i].type == type)
            return &g_bosses[i];
    }
    return nullptr;
}
""".strip()


def clean_name(name):
    return re.sub("[^0-9a-zA-Z_]+", "_", name.upper())


attr_names = ["speed", "hp", "type", "score", "damage", "flags"]
seq_names = ["moving", "attack", "hurt", "death"]

EXIT_FAILURE = 1
EXIT_SUCCESS = 0

with open("demon.ini") as sfile:
    data = sfile.read()

boss_types = []
g_vars = []
defines = []
all_seqs = []
seq = {}
sheet = 0

section = ""
line = 0
frame = 0
for t in data.split("\n"):
    line += 1
    t = t.split("#", 1)[0].strip()
    if not t:
        continue

    e = [x for x in t.split() if x]
    if t[0] == "[" and t[-1] == "]":
        # save previous boss
        if section:
            all_seqs.append(seq)
        seq = {}
        section = t[1:-1].strip()
        if not section:
            print(f"section header empty on line {line}")
            exit(EXIT_FAILURE)
        seq["name"] = section
        seq["sheet"] = sheet
    elif t[0] == "[":
        # save previous boss
        if section:
            all_seqs.append(seq)
        seq = {}
        print(f"section header not terminated on line {line}")
        section = t[1:].strip()
        if not section:
            print(f"section header empty on line {line}")
            exit(EXIT_FAILURE)
        seq["name"] = section
        seq["sheet"] = sheet
    elif e[0] == ">>>sheet" and len(e) == 2:
        sheet = int(e[1])
        print(f"switched to sheet {sheet}")
    elif not section:
        if len(e) != 3:
            print(f"expecting 3 literals on line {line}: {t} -- found {len(e)}")
            continue
        if e[0] == "private":
            name = clean_name(e[1])
            g_vars.append(f"constexpr auto {name} = {e[2]};")
        elif e[0] == "define":
            defines.append(f"#define {e[1].upper()} {e[2]}")
        else:
            f"unknown operator `{e[0]}` on line {line}"
    elif section:
        if len(e) < 2:
            print(f"missing qualifier on line {line}: {t}")
            continue
        item_name = e[0]
        if item_name in seq_names:
            frame_count = int(e[1])
            prefix = clean_name(section)
            suffix = e[0].upper()
            vars = []
            seq_name = item_name
            var_name = f"{prefix}_{suffix}_BASE"
            vars.append(var_name)
            g_vars.append(f"constexpr int {var_name} = {frame};")
            var_name = f"{prefix}_{suffix}_LEN"
            vars.append(var_name)
            g_vars.append(f"constexpr int {var_name} = {frame_count};")

            seq[seq_name] = vars  # [frame, frame_count]
            frame += frame_count
        elif item_name == "flags":
            seq[item_name] = " ".join(e[1:])
        elif item_name in attr_names:
            seq[item_name] = e[1]
        elif item_name == "hitbox":
            seq[item_name] = " ".join(e[1:])
        else:
            print(f"item name {item_name} on {line} is unknown")
    else:
        print(f"unknown data on line {line}: {t}")

if seq:
    all_seqs.append(seq)

"""
bossData_t bosses[] = {
    {
        .moving={},
        .attack={},
        .hurt={},
        .death={},
    }
};
"""

for seq in all_seqs:
    name = clean_name(seq["name"])
    boss_types.append(f"#define BOSS_{name} {seq['type']}")

SPACE = " " * 4
SPACE2 = " " * 8

with open("bossdata.cpp", "w") as tfile:
    tfile.write(notice + "\n\n")
    tfile.write("//////////////////////////////////////////////////\n")
    tfile.write("// autogenerated\n\n")
    tfile.write("#include <cstddef>\n")
    tfile.write('#include "color.h"\n')
    tfile.write('#include "bossdata.h"\n\n')
    tfile.write("namespace BossData\n")
    tfile.write(f"{{\n{SPACE}")
    tfile.write(f"\n{SPACE}".join(g_vars) + "\n")
    tfile.write("};\n\n")
    tfile.write("using namespace BossData;\n\n")
    tfile.write("bossData_t g_bosses[] = {\n")
    for seq in all_seqs:
        tfile.write(f"{SPACE}{{\n")
        code = f"{SPACE2}.name = \"{seq['name']}\",\n"
        tfile.write(code)
        for name in attr_names:
            code = f"{SPACE2}.{name} = {seq[name]},\n"
            tfile.write(code)
        for name in seq_names:
            code = f"{SPACE2}.{name} = {{{seq[name][0]}, {seq[name][1]}}},\n"
            tfile.write(code)
        code = f"{SPACE2}.hitbox = {{{seq['hitbox']}}},\n"
        tfile.write(code)
        code = f"{SPACE2}.sheet = {seq['sheet']},\n"
        tfile.write(code)
        tfile.write(f"{SPACE}}},\n")
    tfile.write(f"}};\n")
    tfile.write("\n" + cpp_body + "\n\n")
with open("bossdata.h", "w") as tfile:
    tfile.write(notice + "\n\n")
    tfile.write("//////////////////////////////////////////////////\n")
    tfile.write("// autogenerated\n\n")
    tfile.write("#pragma once\n\n")
    tfile.write("#include <cstdint>\n")
    tfile.write('#include "rect.h"\n\n')
    tfile.write("\n".join(defines) + "\n\n")
    tfile.write("\n".join(boss_types) + "\n\n")
    tfile.write(struct)
    tfile.write("\nbossData_t *getBossData(const int type);\n")

# ../../src
shutil.copy("bossdata.h", "../../src")
shutil.copy("bossdata.cpp", "../../src")

exit(EXIT_SUCCESS)
